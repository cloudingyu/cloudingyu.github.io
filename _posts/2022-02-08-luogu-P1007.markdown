---
layout:     post
title:      "洛谷P1007 独木桥 题解"
subtitle:   "贪心模拟，看上去很复杂，实际上很简单"
date:       2022-02-08
author:     "CloudingYu"
header-style: text
mathjax: true
tags:
    - 题解
    - 洛谷
---
## [题目描述](https://www.luogu.com.cn/problem/P1002)

棋盘上$A$点有一个过河卒，需要走到目标$B$点。卒行走的规则：可以向下、或者向右。同时在棋盘上$C$点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$点 $(0,0)$，$B$点 $(n,m)$，同样马的位置坐标是需要给出的。

现在要求你计算出卒从$A$点能够到达$B$点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 推状态转移方程
看到题目，就很容易想到这道题用$dp$。因为过河卒只能向下或向右走，根据加法法则，一个点到$B$点的路径数就等于它下方点和右方点的路径数之和，

于是能推出状态转移方程：
### $a [ i ][ j ] = a [ i+1 ][ j ] + a [ i ][ j+1 ];$

## 蒟个栗子
就拿样例来说好了，B点的位置是$(6,6)$，马的位置是$(3,3)$，

运行代码后得到的二维数组应是这样的：

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 0 | 6 | 3 | 3 | 3 | 2 | 2 | 1 |
| 1 | 3 | 0 | 0 | 1 | 0 | 1 | 1 |
| 2 | 3 | 0 | 2 | 1 | 1 | 0 | 1 |
| 3 | 3 | 1 | 1 | 0 | 1 | 1 | 1 |
| 4 | 2 | 0 | 1 | 1 | 0 | 0 | 1 |
| 5 | 2 | 1 | 0 | 1 | 0 | 2 | 1 |
| 6 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

其中状态转移方程就可以体现为

$$
a [ 5 ][ 5 ] = a [ 6 ][ 5 ] + a [ 5 ][ 6 ] = 1 + 1 = 2，
$$



$$

  

\begin{aligned}

  

|\int_A^{A'}f(x)g(x)dx|&\le |g(A)|\cdot |\int_A^\xi f(x)dx|+|g(A')|\cdot |\int_\xi^{A'}f(x)dx|\\

  

& \le 2M|g(A)|+2M|g(A')|<\frac{\epsilon}{2}+\frac{\epsilon}{2}=\epsilon

  

\end{aligned}

  

$$

第六列和第六行因为是边缘，没有右侧的点和下侧的点，于是就都等于1，也就相当于它们到B点的路径只有一条。

实现只需要用循环嵌套就可以了。


## 代码实现看这里

```
#include<iostream>
using namespace std;
long long a[22][22];//代表该点到B点的路径数（因为最大是20*20，所以要开long long）
int bx,by,mx,my;//定义B点的坐标和马的坐标
int u[9]={0,1,2,1,2,-1,-2,-1,-2},
    v[9]={0,-2,-1,2,1,2,1,-2,-1};
bool b[22][22];//确认此点能否通过
int main()
{
    cin>>bx>>by>>mx>>my;//读入B点坐标和马的坐标
    int x,y;
    
    for(int i=1;i<=8;i++)//依次枚举马能走的位置
    {
        x=mx+u[i];
        y=my+v[i];
        if(x>=0&&y>=0&&x<=bx&&y<=by)//如果马能走的位置在棋盘内
           b[x][y]=1;//将b[i][j]设为不能通过
    }
    
    b[mx][my]=1;//将马的位置设为不能通过
    b[bx][by]=1;//防止B点的位置被更新
    a[bx][by]=1;//设初始值，表示B点到B点的路径只有一条
    for(int i=bx;i>=0;i--)
        for(int j=by;j>=0;j--)
            if(!b[i][j])//如果此点能走
                a[i][j]=a[i+1][j]+a[i][j+1];//更新(i,j)的值          
                
    cout<<a[0][0]<<endl;//输出（0，0）到B点的路径数
    return 0;
}

```

嘿嘿第一次写题解vAv

