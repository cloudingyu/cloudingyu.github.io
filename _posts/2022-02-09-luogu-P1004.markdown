---
layout:     post
title:      "洛谷P1004 方格取数"
subtitle:   "四维动态规划，属于是模版题"
date:       2022-02-09
author:     "CloudingYu"
header-style: picture
mathjax: true
tags:
    - 题解
    - 洛谷
---
## [题目描述](https://www.luogu.com.cn/problem/P1004)
设有 $N$ $×$ $N$ 的方格图 $($ $N$ $≤$ $9$ $)$ ，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$ 。如下图所示（见样例）:
```
A
 0  0  0  0  0  0  0  0
 0  0 13  0  0  6  0  0
 0  0  0  0  7  0  0  0
 0  0  0 14  0  0  0  0
 0 21  0  0  0  4  0  0
 0  0 15  0  0  0  0  0
 0 14  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
                         B
```
某人从图的左上角的 $A$ 点出发，可以**向下行走，也可以向右走**，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$ ）。

此人从 $A$ 点到 $B$ 点共走**两次**，试找出 $2$ 条这样的路径，使得取得的数之和为最大。

#### 输入格式
输入的第一行为一个整数 $N$ （表示 $N$ $×$ $N$ 的方格图），接下来的每行有三个整数，前两个表示**位置**，第三个数为该位置上所放的**数**。一行单独的 $0$表示输入结束。
```
样例输入:
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

#### 输出格式
只需输出一个整数，表示 $2$ 条路径上取得的最大的和。


## 推状态转移方程
这是道很明显的多维 $DP$ 题目。因为是 $2$ 条路径，所以同时需要 $dp$两个点，使用四维数组。

定义一个四维数组，$\displaystyle dp[ i ][ j ][ k ][ l ]$的值表示第一条路径到点 $\displaystyle ( i , j )$ ，第二条路径到点$\displaystyle ( k , l )$时所取的最大数之和，
因为只能**向下或向右**行走，于是就能得到状态转移方程：

```
dp[ i ][ j ][ k ][ l ] = max(dp[ i-1 ][ j ][ k-1 ][ l ],dp[ i ][ j-1 ][ k ][ l-1 ],dp[ i-1 ][ j ][ k ][ l-1 ],dp[ i ][ j-1 ][ k-1 ][ l ]) + a[ i ][ j ]+a[ k ][ l ]
```

其中：$\displaystyle a[ i ][ j ]$代表点 $\displaystyle ( i , j )$上的数字大小

这里注意，第一条路径经过后会将格子中的数拿走，当 $i=k$ 且 $j=l$ 时，因为已经被第一条路径取走了，**不需要再增加 $\displaystyle a[ k ][ l ]$ 的值**。


## 蒟个栗子
还是看样例:
```
A 
 0  0  0  0  0  0  0  0
 0  0 13  0  0  6  0  0
 0  0  0  0  7  0  0  0
 0  0  0 14  0  0  0  0
 0 21  0  0  0  4  0  0
 0  0 15  0  0  0  0  0
 0 14  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
                         B
```
通过四重循环，我们可以得到两条数字和最大的路径分别为，穿过 $13-14-4$ 和穿过 $21-15$ ，总和为 $67$ 。

## 代码实现看这里
```
#include <iostream>
using namespace std;
int a[12][12], dp[12][12][12][12], n, x, y, t;
int main()
{
    cin >> n;
    cin >> x >> y >> t;
    while (x && y && t) // 若都为0则输入结束
    {
        a[x][y] = t;
        cin >> x >> y >> t;
    }
    for (int i = 1; i <= n; i++) // 四重循环
        for (int j = 1; j <= n; j++)
            for (int k = 1; k <= n; k++)
                for (int l = 1; l <= n; l++)
                {
                    dp[i][j][k][l] = max(max(dp[i - 1][j][k - 1][l], dp[i][j - 1][k][l - 1]), max(dp[i - 1][j][k][l - 1], dp[i][j - 1][k - 1][l])) + a[i][j];
                    if (i != k && j != l) // 判断是否为同一点
                        dp[i][j][k][l] += a[k][l];
                }
    cout << dp[n][n][n][n] << endl;
    return 0;
}
```